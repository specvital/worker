// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAnalysis = `-- name: CreateAnalysis :one
INSERT INTO analyses (id, codebase_id, commit_sha, branch_name, status, started_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, codebase_id, commit_sha, branch_name, status, error_message, started_at, completed_at, created_at, total_suites, total_tests
`

type CreateAnalysisParams struct {
	ID         pgtype.UUID        `json:"id"`
	CodebaseID pgtype.UUID        `json:"codebase_id"`
	CommitSha  string             `json:"commit_sha"`
	BranchName pgtype.Text        `json:"branch_name"`
	Status     AnalysisStatus     `json:"status"`
	StartedAt  pgtype.Timestamptz `json:"started_at"`
}

func (q *Queries) CreateAnalysis(ctx context.Context, arg CreateAnalysisParams) (Analysis, error) {
	row := q.db.QueryRow(ctx, createAnalysis,
		arg.ID,
		arg.CodebaseID,
		arg.CommitSha,
		arg.BranchName,
		arg.Status,
		arg.StartedAt,
	)
	var i Analysis
	err := row.Scan(
		&i.ID,
		&i.CodebaseID,
		&i.CommitSha,
		&i.BranchName,
		&i.Status,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.TotalSuites,
		&i.TotalTests,
	)
	return i, err
}

const createTestCase = `-- name: CreateTestCase :one
INSERT INTO test_cases (suite_id, name, line_number, status, tags, modifier)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, suite_id, name, line_number, status, tags, modifier
`

type CreateTestCaseParams struct {
	SuiteID    pgtype.UUID `json:"suite_id"`
	Name       string      `json:"name"`
	LineNumber pgtype.Int4 `json:"line_number"`
	Status     TestStatus  `json:"status"`
	Tags       []byte      `json:"tags"`
	Modifier   pgtype.Text `json:"modifier"`
}

func (q *Queries) CreateTestCase(ctx context.Context, arg CreateTestCaseParams) (TestCase, error) {
	row := q.db.QueryRow(ctx, createTestCase,
		arg.SuiteID,
		arg.Name,
		arg.LineNumber,
		arg.Status,
		arg.Tags,
		arg.Modifier,
	)
	var i TestCase
	err := row.Scan(
		&i.ID,
		&i.SuiteID,
		&i.Name,
		&i.LineNumber,
		&i.Status,
		&i.Tags,
		&i.Modifier,
	)
	return i, err
}

const createTestSuite = `-- name: CreateTestSuite :one
INSERT INTO test_suites (analysis_id, parent_id, name, file_path, line_number, framework, depth)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, analysis_id, parent_id, name, file_path, line_number, framework, depth
`

type CreateTestSuiteParams struct {
	AnalysisID pgtype.UUID `json:"analysis_id"`
	ParentID   pgtype.UUID `json:"parent_id"`
	Name       string      `json:"name"`
	FilePath   string      `json:"file_path"`
	LineNumber pgtype.Int4 `json:"line_number"`
	Framework  pgtype.Text `json:"framework"`
	Depth      int32       `json:"depth"`
}

func (q *Queries) CreateTestSuite(ctx context.Context, arg CreateTestSuiteParams) (TestSuite, error) {
	row := q.db.QueryRow(ctx, createTestSuite,
		arg.AnalysisID,
		arg.ParentID,
		arg.Name,
		arg.FilePath,
		arg.LineNumber,
		arg.Framework,
		arg.Depth,
	)
	var i TestSuite
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.ParentID,
		&i.Name,
		&i.FilePath,
		&i.LineNumber,
		&i.Framework,
		&i.Depth,
	)
	return i, err
}

const findCodebaseByExternalID = `-- name: FindCodebaseByExternalID :one
SELECT id, host, owner, name, default_branch, created_at, updated_at, last_viewed_at, external_repo_id, is_stale FROM codebases
WHERE host = $1 AND external_repo_id = $2
`

type FindCodebaseByExternalIDParams struct {
	Host           string `json:"host"`
	ExternalRepoID string `json:"external_repo_id"`
}

func (q *Queries) FindCodebaseByExternalID(ctx context.Context, arg FindCodebaseByExternalIDParams) (Codebasis, error) {
	row := q.db.QueryRow(ctx, findCodebaseByExternalID, arg.Host, arg.ExternalRepoID)
	var i Codebasis
	err := row.Scan(
		&i.ID,
		&i.Host,
		&i.Owner,
		&i.Name,
		&i.DefaultBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastViewedAt,
		&i.ExternalRepoID,
		&i.IsStale,
	)
	return i, err
}

const findCodebaseByOwnerName = `-- name: FindCodebaseByOwnerName :one
SELECT id, host, owner, name, default_branch, created_at, updated_at, last_viewed_at, external_repo_id, is_stale FROM codebases
WHERE host = $1 AND owner = $2 AND name = $3 AND is_stale = false
`

type FindCodebaseByOwnerNameParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

func (q *Queries) FindCodebaseByOwnerName(ctx context.Context, arg FindCodebaseByOwnerNameParams) (Codebasis, error) {
	row := q.db.QueryRow(ctx, findCodebaseByOwnerName, arg.Host, arg.Owner, arg.Name)
	var i Codebasis
	err := row.Scan(
		&i.ID,
		&i.Host,
		&i.Owner,
		&i.Name,
		&i.DefaultBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastViewedAt,
		&i.ExternalRepoID,
		&i.IsStale,
	)
	return i, err
}

const findCodebaseWithLastCommitByOwnerName = `-- name: FindCodebaseWithLastCommitByOwnerName :one
SELECT
    c.id, c.host, c.owner, c.name, c.default_branch, c.created_at, c.updated_at, c.last_viewed_at, c.external_repo_id, c.is_stale,
    COALESCE(a.commit_sha, '') as last_commit_sha
FROM codebases c
LEFT JOIN (
    SELECT DISTINCT ON (codebase_id) codebase_id, commit_sha
    FROM analyses
    WHERE status = 'completed'
    ORDER BY codebase_id, completed_at DESC
) a ON c.id = a.codebase_id
WHERE c.host = $1 AND c.owner = $2 AND c.name = $3 AND c.is_stale = false
`

type FindCodebaseWithLastCommitByOwnerNameParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

type FindCodebaseWithLastCommitByOwnerNameRow struct {
	ID             pgtype.UUID        `json:"id"`
	Host           string             `json:"host"`
	Owner          string             `json:"owner"`
	Name           string             `json:"name"`
	DefaultBranch  pgtype.Text        `json:"default_branch"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	LastViewedAt   pgtype.Timestamptz `json:"last_viewed_at"`
	ExternalRepoID string             `json:"external_repo_id"`
	IsStale        bool               `json:"is_stale"`
	LastCommitSha  string             `json:"last_commit_sha"`
}

func (q *Queries) FindCodebaseWithLastCommitByOwnerName(ctx context.Context, arg FindCodebaseWithLastCommitByOwnerNameParams) (FindCodebaseWithLastCommitByOwnerNameRow, error) {
	row := q.db.QueryRow(ctx, findCodebaseWithLastCommitByOwnerName, arg.Host, arg.Owner, arg.Name)
	var i FindCodebaseWithLastCommitByOwnerNameRow
	err := row.Scan(
		&i.ID,
		&i.Host,
		&i.Owner,
		&i.Name,
		&i.DefaultBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastViewedAt,
		&i.ExternalRepoID,
		&i.IsStale,
		&i.LastCommitSha,
	)
	return i, err
}

const getCodebaseByID = `-- name: GetCodebaseByID :one
SELECT id, host, owner, name, default_branch, created_at, updated_at, last_viewed_at, external_repo_id, is_stale FROM codebases WHERE id = $1
`

func (q *Queries) GetCodebaseByID(ctx context.Context, id pgtype.UUID) (Codebasis, error) {
	row := q.db.QueryRow(ctx, getCodebaseByID, id)
	var i Codebasis
	err := row.Scan(
		&i.ID,
		&i.Host,
		&i.Owner,
		&i.Name,
		&i.DefaultBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastViewedAt,
		&i.ExternalRepoID,
		&i.IsStale,
	)
	return i, err
}

const getCodebasesForAutoRefresh = `-- name: GetCodebasesForAutoRefresh :many
WITH latest_completions AS (
    SELECT DISTINCT ON (codebase_id)
        codebase_id,
        completed_at,
        commit_sha
    FROM analyses
    WHERE status = 'completed'
    ORDER BY codebase_id, completed_at DESC
),
failure_counts AS (
    SELECT
        a.codebase_id,
        COUNT(*)::int as failure_count
    FROM analyses a
    LEFT JOIN latest_completions lc ON a.codebase_id = lc.codebase_id
    WHERE a.status = 'failed'
      AND a.created_at > COALESCE(lc.completed_at, '1970-01-01'::timestamptz)
    GROUP BY a.codebase_id
)
SELECT
    c.id, c.host, c.owner, c.name, c.last_viewed_at,
    lc.completed_at as last_completed_at,
    lc.commit_sha as last_commit_sha,
    COALESCE(fc.failure_count, 0)::int as consecutive_failures
FROM codebases c
LEFT JOIN latest_completions lc ON c.id = lc.codebase_id
LEFT JOIN failure_counts fc ON c.id = fc.codebase_id
WHERE c.last_viewed_at IS NOT NULL
  AND c.last_viewed_at > now() - interval '90 days'
`

type GetCodebasesForAutoRefreshRow struct {
	ID                  pgtype.UUID        `json:"id"`
	Host                string             `json:"host"`
	Owner               string             `json:"owner"`
	Name                string             `json:"name"`
	LastViewedAt        pgtype.Timestamptz `json:"last_viewed_at"`
	LastCompletedAt     pgtype.Timestamptz `json:"last_completed_at"`
	LastCommitSha       pgtype.Text        `json:"last_commit_sha"`
	ConsecutiveFailures int32              `json:"consecutive_failures"`
}

func (q *Queries) GetCodebasesForAutoRefresh(ctx context.Context) ([]GetCodebasesForAutoRefreshRow, error) {
	rows, err := q.db.Query(ctx, getCodebasesForAutoRefresh)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCodebasesForAutoRefreshRow{}
	for rows.Next() {
		var i GetCodebasesForAutoRefreshRow
		if err := rows.Scan(
			&i.ID,
			&i.Host,
			&i.Owner,
			&i.Name,
			&i.LastViewedAt,
			&i.LastCompletedAt,
			&i.LastCommitSha,
			&i.ConsecutiveFailures,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOAuthAccountByUserAndProvider = `-- name: GetOAuthAccountByUserAndProvider :one
SELECT id, user_id, provider, provider_user_id, provider_username, access_token, scope, created_at, updated_at FROM oauth_accounts WHERE user_id = $1 AND provider = $2
`

type GetOAuthAccountByUserAndProviderParams struct {
	UserID   pgtype.UUID   `json:"user_id"`
	Provider OauthProvider `json:"provider"`
}

func (q *Queries) GetOAuthAccountByUserAndProvider(ctx context.Context, arg GetOAuthAccountByUserAndProviderParams) (OauthAccount, error) {
	row := q.db.QueryRow(ctx, getOAuthAccountByUserAndProvider, arg.UserID, arg.Provider)
	var i OauthAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.ProviderUserID,
		&i.ProviderUsername,
		&i.AccessToken,
		&i.Scope,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTestCasesBySuiteID = `-- name: GetTestCasesBySuiteID :many
SELECT id, suite_id, name, line_number, status, tags, modifier FROM test_cases WHERE suite_id = $1 ORDER BY line_number
`

func (q *Queries) GetTestCasesBySuiteID(ctx context.Context, suiteID pgtype.UUID) ([]TestCase, error) {
	rows, err := q.db.Query(ctx, getTestCasesBySuiteID, suiteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TestCase{}
	for rows.Next() {
		var i TestCase
		if err := rows.Scan(
			&i.ID,
			&i.SuiteID,
			&i.Name,
			&i.LineNumber,
			&i.Status,
			&i.Tags,
			&i.Modifier,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestSuitesByAnalysisID = `-- name: GetTestSuitesByAnalysisID :many
SELECT id, analysis_id, parent_id, name, file_path, line_number, framework, depth FROM test_suites WHERE analysis_id = $1 ORDER BY file_path, line_number
`

func (q *Queries) GetTestSuitesByAnalysisID(ctx context.Context, analysisID pgtype.UUID) ([]TestSuite, error) {
	rows, err := q.db.Query(ctx, getTestSuitesByAnalysisID, analysisID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TestSuite{}
	for rows.Next() {
		var i TestSuite
		if err := rows.Scan(
			&i.ID,
			&i.AnalysisID,
			&i.ParentID,
			&i.Name,
			&i.FilePath,
			&i.LineNumber,
			&i.Framework,
			&i.Depth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markCodebaseStale = `-- name: MarkCodebaseStale :exec
UPDATE codebases SET is_stale = true, updated_at = now() WHERE id = $1
`

func (q *Queries) MarkCodebaseStale(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markCodebaseStale, id)
	return err
}

const unmarkCodebaseStale = `-- name: UnmarkCodebaseStale :one
UPDATE codebases
SET is_stale = false, owner = $2, name = $3, updated_at = now()
WHERE id = $1
RETURNING id, host, owner, name, default_branch, created_at, updated_at, last_viewed_at, external_repo_id, is_stale
`

type UnmarkCodebaseStaleParams struct {
	ID    pgtype.UUID `json:"id"`
	Owner string      `json:"owner"`
	Name  string      `json:"name"`
}

func (q *Queries) UnmarkCodebaseStale(ctx context.Context, arg UnmarkCodebaseStaleParams) (Codebasis, error) {
	row := q.db.QueryRow(ctx, unmarkCodebaseStale, arg.ID, arg.Owner, arg.Name)
	var i Codebasis
	err := row.Scan(
		&i.ID,
		&i.Host,
		&i.Owner,
		&i.Name,
		&i.DefaultBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastViewedAt,
		&i.ExternalRepoID,
		&i.IsStale,
	)
	return i, err
}

const updateAnalysisCompleted = `-- name: UpdateAnalysisCompleted :exec
UPDATE analyses
SET status = 'completed', total_suites = $2, total_tests = $3, completed_at = $4
WHERE id = $1
`

type UpdateAnalysisCompletedParams struct {
	ID          pgtype.UUID        `json:"id"`
	TotalSuites int32              `json:"total_suites"`
	TotalTests  int32              `json:"total_tests"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) UpdateAnalysisCompleted(ctx context.Context, arg UpdateAnalysisCompletedParams) error {
	_, err := q.db.Exec(ctx, updateAnalysisCompleted,
		arg.ID,
		arg.TotalSuites,
		arg.TotalTests,
		arg.CompletedAt,
	)
	return err
}

const updateAnalysisFailed = `-- name: UpdateAnalysisFailed :exec
UPDATE analyses
SET status = 'failed', error_message = $2, completed_at = $3
WHERE id = $1
`

type UpdateAnalysisFailedParams struct {
	ID           pgtype.UUID        `json:"id"`
	ErrorMessage pgtype.Text        `json:"error_message"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) UpdateAnalysisFailed(ctx context.Context, arg UpdateAnalysisFailedParams) error {
	_, err := q.db.Exec(ctx, updateAnalysisFailed, arg.ID, arg.ErrorMessage, arg.CompletedAt)
	return err
}

const updateCodebaseOwnerName = `-- name: UpdateCodebaseOwnerName :one
UPDATE codebases
SET owner = $2, name = $3, updated_at = now()
WHERE id = $1
RETURNING id, host, owner, name, default_branch, created_at, updated_at, last_viewed_at, external_repo_id, is_stale
`

type UpdateCodebaseOwnerNameParams struct {
	ID    pgtype.UUID `json:"id"`
	Owner string      `json:"owner"`
	Name  string      `json:"name"`
}

func (q *Queries) UpdateCodebaseOwnerName(ctx context.Context, arg UpdateCodebaseOwnerNameParams) (Codebasis, error) {
	row := q.db.QueryRow(ctx, updateCodebaseOwnerName, arg.ID, arg.Owner, arg.Name)
	var i Codebasis
	err := row.Scan(
		&i.ID,
		&i.Host,
		&i.Owner,
		&i.Name,
		&i.DefaultBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastViewedAt,
		&i.ExternalRepoID,
		&i.IsStale,
	)
	return i, err
}

const upsertCodebase = `-- name: UpsertCodebase :one
INSERT INTO codebases (host, owner, name, default_branch, external_repo_id)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (host, external_repo_id)
DO UPDATE SET
    owner = EXCLUDED.owner,
    name = EXCLUDED.name,
    default_branch = COALESCE(EXCLUDED.default_branch, codebases.default_branch),
    is_stale = false,
    updated_at = now()
RETURNING id, host, owner, name, default_branch, created_at, updated_at, last_viewed_at, external_repo_id, is_stale
`

type UpsertCodebaseParams struct {
	Host           string      `json:"host"`
	Owner          string      `json:"owner"`
	Name           string      `json:"name"`
	DefaultBranch  pgtype.Text `json:"default_branch"`
	ExternalRepoID string      `json:"external_repo_id"`
}

func (q *Queries) UpsertCodebase(ctx context.Context, arg UpsertCodebaseParams) (Codebasis, error) {
	row := q.db.QueryRow(ctx, upsertCodebase,
		arg.Host,
		arg.Owner,
		arg.Name,
		arg.DefaultBranch,
		arg.ExternalRepoID,
	)
	var i Codebasis
	err := row.Scan(
		&i.ID,
		&i.Host,
		&i.Owner,
		&i.Name,
		&i.DefaultBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastViewedAt,
		&i.ExternalRepoID,
		&i.IsStale,
	)
	return i, err
}
