// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkAnalysisExists = `-- name: CheckAnalysisExists :one
SELECT EXISTS(SELECT 1 FROM analyses WHERE id = $1) as exists
`

func (q *Queries) CheckAnalysisExists(ctx context.Context, id pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkAnalysisExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createAnalysis = `-- name: CreateAnalysis :one
INSERT INTO analyses (id, codebase_id, commit_sha, branch_name, status, started_at, parser_version)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, codebase_id, commit_sha, branch_name, status, error_message, started_at, completed_at, created_at, total_suites, total_tests, committed_at, parser_version
`

type CreateAnalysisParams struct {
	ID            pgtype.UUID        `json:"id"`
	CodebaseID    pgtype.UUID        `json:"codebase_id"`
	CommitSha     string             `json:"commit_sha"`
	BranchName    pgtype.Text        `json:"branch_name"`
	Status        AnalysisStatus     `json:"status"`
	StartedAt     pgtype.Timestamptz `json:"started_at"`
	ParserVersion string             `json:"parser_version"`
}

func (q *Queries) CreateAnalysis(ctx context.Context, arg CreateAnalysisParams) (Analysis, error) {
	row := q.db.QueryRow(ctx, createAnalysis,
		arg.ID,
		arg.CodebaseID,
		arg.CommitSha,
		arg.BranchName,
		arg.Status,
		arg.StartedAt,
		arg.ParserVersion,
	)
	var i Analysis
	err := row.Scan(
		&i.ID,
		&i.CodebaseID,
		&i.CommitSha,
		&i.BranchName,
		&i.Status,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.TotalSuites,
		&i.TotalTests,
		&i.CommittedAt,
		&i.ParserVersion,
	)
	return i, err
}

const createTestCase = `-- name: CreateTestCase :one
INSERT INTO test_cases (suite_id, name, line_number, status, tags, modifier)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, suite_id, name, line_number, status, tags, modifier
`

type CreateTestCaseParams struct {
	SuiteID    pgtype.UUID `json:"suite_id"`
	Name       string      `json:"name"`
	LineNumber pgtype.Int4 `json:"line_number"`
	Status     TestStatus  `json:"status"`
	Tags       []byte      `json:"tags"`
	Modifier   pgtype.Text `json:"modifier"`
}

func (q *Queries) CreateTestCase(ctx context.Context, arg CreateTestCaseParams) (TestCase, error) {
	row := q.db.QueryRow(ctx, createTestCase,
		arg.SuiteID,
		arg.Name,
		arg.LineNumber,
		arg.Status,
		arg.Tags,
		arg.Modifier,
	)
	var i TestCase
	err := row.Scan(
		&i.ID,
		&i.SuiteID,
		&i.Name,
		&i.LineNumber,
		&i.Status,
		&i.Tags,
		&i.Modifier,
	)
	return i, err
}

const deleteExpiredClassificationCaches = `-- name: DeleteExpiredClassificationCaches :execrows
DELETE FROM classification_caches
WHERE created_at < now() - $1::interval
`

func (q *Queries) DeleteExpiredClassificationCaches(ctx context.Context, dollar_1 pgtype.Interval) (int64, error) {
	result, err := q.db.Exec(ctx, deleteExpiredClassificationCaches, dollar_1)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findBehaviorCachesByHashes = `-- name: FindBehaviorCachesByHashes :many

SELECT cache_key_hash, converted_description
FROM behavior_caches
WHERE cache_key_hash = ANY($1::bytea[])
`

type FindBehaviorCachesByHashesRow struct {
	CacheKeyHash         []byte `json:"cache_key_hash"`
	ConvertedDescription string `json:"converted_description"`
}

// =============================================================================
// BEHAVIOR CACHES
// =============================================================================
func (q *Queries) FindBehaviorCachesByHashes(ctx context.Context, dollar_1 [][]byte) ([]FindBehaviorCachesByHashesRow, error) {
	rows, err := q.db.Query(ctx, findBehaviorCachesByHashes, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindBehaviorCachesByHashesRow{}
	for rows.Next() {
		var i FindBehaviorCachesByHashesRow
		if err := rows.Scan(&i.CacheKeyHash, &i.ConvertedDescription); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findClassificationCacheByKey = `-- name: FindClassificationCacheByKey :one

SELECT id, content_hash, language, model_id, phase1_output, test_index_map, created_at
FROM classification_caches
WHERE content_hash = $1 AND language = $2 AND model_id = $3
`

type FindClassificationCacheByKeyParams struct {
	ContentHash []byte `json:"content_hash"`
	Language    string `json:"language"`
	ModelID     string `json:"model_id"`
}

// =============================================================================
// CLASSIFICATION CACHES
// =============================================================================
func (q *Queries) FindClassificationCacheByKey(ctx context.Context, arg FindClassificationCacheByKeyParams) (ClassificationCach, error) {
	row := q.db.QueryRow(ctx, findClassificationCacheByKey, arg.ContentHash, arg.Language, arg.ModelID)
	var i ClassificationCach
	err := row.Scan(
		&i.ID,
		&i.ContentHash,
		&i.Language,
		&i.ModelID,
		&i.Phase1Output,
		&i.TestIndexMap,
		&i.CreatedAt,
	)
	return i, err
}

const findCodebaseByExternalID = `-- name: FindCodebaseByExternalID :one
SELECT id, host, owner, name, default_branch, created_at, updated_at, last_viewed_at, external_repo_id, is_stale, is_private FROM codebases
WHERE host = $1 AND external_repo_id = $2
`

type FindCodebaseByExternalIDParams struct {
	Host           string `json:"host"`
	ExternalRepoID string `json:"external_repo_id"`
}

func (q *Queries) FindCodebaseByExternalID(ctx context.Context, arg FindCodebaseByExternalIDParams) (Codebasis, error) {
	row := q.db.QueryRow(ctx, findCodebaseByExternalID, arg.Host, arg.ExternalRepoID)
	var i Codebasis
	err := row.Scan(
		&i.ID,
		&i.Host,
		&i.Owner,
		&i.Name,
		&i.DefaultBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastViewedAt,
		&i.ExternalRepoID,
		&i.IsStale,
		&i.IsPrivate,
	)
	return i, err
}

const findCodebaseByOwnerName = `-- name: FindCodebaseByOwnerName :one
SELECT id, host, owner, name, default_branch, created_at, updated_at, last_viewed_at, external_repo_id, is_stale, is_private FROM codebases
WHERE host = $1 AND owner = $2 AND name = $3 AND is_stale = false
`

type FindCodebaseByOwnerNameParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

func (q *Queries) FindCodebaseByOwnerName(ctx context.Context, arg FindCodebaseByOwnerNameParams) (Codebasis, error) {
	row := q.db.QueryRow(ctx, findCodebaseByOwnerName, arg.Host, arg.Owner, arg.Name)
	var i Codebasis
	err := row.Scan(
		&i.ID,
		&i.Host,
		&i.Owner,
		&i.Name,
		&i.DefaultBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastViewedAt,
		&i.ExternalRepoID,
		&i.IsStale,
		&i.IsPrivate,
	)
	return i, err
}

const findCodebaseWithLastCommitByOwnerName = `-- name: FindCodebaseWithLastCommitByOwnerName :one
SELECT
    c.id, c.host, c.owner, c.name, c.default_branch, c.created_at, c.updated_at, c.last_viewed_at, c.external_repo_id, c.is_stale, c.is_private,
    COALESCE(a.commit_sha, '') as last_commit_sha
FROM codebases c
LEFT JOIN (
    SELECT DISTINCT ON (codebase_id) codebase_id, commit_sha
    FROM analyses
    WHERE status = 'completed'
    ORDER BY codebase_id, completed_at DESC
) a ON c.id = a.codebase_id
WHERE c.host = $1 AND c.owner = $2 AND c.name = $3 AND c.is_stale = false
`

type FindCodebaseWithLastCommitByOwnerNameParams struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Name  string `json:"name"`
}

type FindCodebaseWithLastCommitByOwnerNameRow struct {
	ID             pgtype.UUID        `json:"id"`
	Host           string             `json:"host"`
	Owner          string             `json:"owner"`
	Name           string             `json:"name"`
	DefaultBranch  pgtype.Text        `json:"default_branch"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	LastViewedAt   pgtype.Timestamptz `json:"last_viewed_at"`
	ExternalRepoID string             `json:"external_repo_id"`
	IsStale        bool               `json:"is_stale"`
	IsPrivate      bool               `json:"is_private"`
	LastCommitSha  string             `json:"last_commit_sha"`
}

func (q *Queries) FindCodebaseWithLastCommitByOwnerName(ctx context.Context, arg FindCodebaseWithLastCommitByOwnerNameParams) (FindCodebaseWithLastCommitByOwnerNameRow, error) {
	row := q.db.QueryRow(ctx, findCodebaseWithLastCommitByOwnerName, arg.Host, arg.Owner, arg.Name)
	var i FindCodebaseWithLastCommitByOwnerNameRow
	err := row.Scan(
		&i.ID,
		&i.Host,
		&i.Owner,
		&i.Name,
		&i.DefaultBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastViewedAt,
		&i.ExternalRepoID,
		&i.IsStale,
		&i.IsPrivate,
		&i.LastCommitSha,
	)
	return i, err
}

const findSpecDocumentByContentHash = `-- name: FindSpecDocumentByContentHash :one
SELECT sd.id, sd.analysis_id, sd.content_hash, sd.language, sd.executive_summary, sd.model_id, sd.created_at, sd.updated_at, sd.version, sd.user_id FROM spec_documents sd
WHERE sd.user_id = $1
  AND sd.content_hash = $2
  AND sd.language = $3
  AND sd.model_id = $4
  AND sd.version = (
    SELECT MAX(version)
    FROM spec_documents
    WHERE user_id = sd.user_id
      AND analysis_id = sd.analysis_id
      AND language = sd.language
  )
`

type FindSpecDocumentByContentHashParams struct {
	UserID      pgtype.UUID `json:"user_id"`
	ContentHash []byte      `json:"content_hash"`
	Language    string      `json:"language"`
	ModelID     string      `json:"model_id"`
}

func (q *Queries) FindSpecDocumentByContentHash(ctx context.Context, arg FindSpecDocumentByContentHashParams) (SpecDocument, error) {
	row := q.db.QueryRow(ctx, findSpecDocumentByContentHash,
		arg.UserID,
		arg.ContentHash,
		arg.Language,
		arg.ModelID,
	)
	var i SpecDocument
	err := row.Scan(
		&i.ID,
		&i.AnalysisID,
		&i.ContentHash,
		&i.Language,
		&i.ExecutiveSummary,
		&i.ModelID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.UserID,
	)
	return i, err
}

const getAnalysisContext = `-- name: GetAnalysisContext :one
SELECT c.host, c.owner, c.name as repo
FROM analyses a
JOIN codebases c ON a.codebase_id = c.id
WHERE a.id = $1
`

type GetAnalysisContextRow struct {
	Host  string `json:"host"`
	Owner string `json:"owner"`
	Repo  string `json:"repo"`
}

func (q *Queries) GetAnalysisContext(ctx context.Context, id pgtype.UUID) (GetAnalysisContextRow, error) {
	row := q.db.QueryRow(ctx, getAnalysisContext, id)
	var i GetAnalysisContextRow
	err := row.Scan(&i.Host, &i.Owner, &i.Repo)
	return i, err
}

const getCodebaseByID = `-- name: GetCodebaseByID :one
SELECT id, host, owner, name, default_branch, created_at, updated_at, last_viewed_at, external_repo_id, is_stale, is_private FROM codebases WHERE id = $1
`

func (q *Queries) GetCodebaseByID(ctx context.Context, id pgtype.UUID) (Codebasis, error) {
	row := q.db.QueryRow(ctx, getCodebaseByID, id)
	var i Codebasis
	err := row.Scan(
		&i.ID,
		&i.Host,
		&i.Owner,
		&i.Name,
		&i.DefaultBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastViewedAt,
		&i.ExternalRepoID,
		&i.IsStale,
		&i.IsPrivate,
	)
	return i, err
}

const getCodebasesForAutoRefresh = `-- name: GetCodebasesForAutoRefresh :many
WITH latest_completions AS (
    SELECT DISTINCT ON (codebase_id)
        codebase_id,
        completed_at,
        commit_sha,
        parser_version
    FROM analyses
    WHERE status = 'completed'
    ORDER BY codebase_id, completed_at DESC
),
failure_counts AS (
    SELECT
        a.codebase_id,
        COUNT(*)::int as failure_count
    FROM analyses a
    LEFT JOIN latest_completions lc ON a.codebase_id = lc.codebase_id
    WHERE a.status = 'failed'
      AND a.created_at > COALESCE(lc.completed_at, '1970-01-01'::timestamptz)
    GROUP BY a.codebase_id
)
SELECT
    c.id, c.host, c.owner, c.name, c.last_viewed_at,
    lc.completed_at as last_completed_at,
    lc.commit_sha as last_commit_sha,
    COALESCE(lc.parser_version, 'legacy') as last_parser_version,
    COALESCE(fc.failure_count, 0)::int as consecutive_failures
FROM codebases c
LEFT JOIN latest_completions lc ON c.id = lc.codebase_id
LEFT JOIN failure_counts fc ON c.id = fc.codebase_id
WHERE c.last_viewed_at IS NOT NULL
  AND c.last_viewed_at > now() - interval '90 days'
  AND c.is_stale = false
  AND c.is_private = false
`

type GetCodebasesForAutoRefreshRow struct {
	ID                  pgtype.UUID        `json:"id"`
	Host                string             `json:"host"`
	Owner               string             `json:"owner"`
	Name                string             `json:"name"`
	LastViewedAt        pgtype.Timestamptz `json:"last_viewed_at"`
	LastCompletedAt     pgtype.Timestamptz `json:"last_completed_at"`
	LastCommitSha       pgtype.Text        `json:"last_commit_sha"`
	LastParserVersion   string             `json:"last_parser_version"`
	ConsecutiveFailures int32              `json:"consecutive_failures"`
}

func (q *Queries) GetCodebasesForAutoRefresh(ctx context.Context) ([]GetCodebasesForAutoRefreshRow, error) {
	rows, err := q.db.Query(ctx, getCodebasesForAutoRefresh)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCodebasesForAutoRefreshRow{}
	for rows.Next() {
		var i GetCodebasesForAutoRefreshRow
		if err := rows.Scan(
			&i.ID,
			&i.Host,
			&i.Owner,
			&i.Name,
			&i.LastViewedAt,
			&i.LastCompletedAt,
			&i.LastCommitSha,
			&i.LastParserVersion,
			&i.ConsecutiveFailures,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaxVersionByUserAnalysisAndLanguage = `-- name: GetMaxVersionByUserAnalysisAndLanguage :one

SELECT COALESCE(MAX(version), 0)::int as max_version
FROM spec_documents
WHERE user_id = $1 AND analysis_id = $2 AND language = $3
`

type GetMaxVersionByUserAnalysisAndLanguageParams struct {
	UserID     pgtype.UUID `json:"user_id"`
	AnalysisID pgtype.UUID `json:"analysis_id"`
	Language   string      `json:"language"`
}

// =============================================================================
// SPEC DOCUMENTS
// =============================================================================
func (q *Queries) GetMaxVersionByUserAnalysisAndLanguage(ctx context.Context, arg GetMaxVersionByUserAnalysisAndLanguageParams) (int32, error) {
	row := q.db.QueryRow(ctx, getMaxVersionByUserAnalysisAndLanguage, arg.UserID, arg.AnalysisID, arg.Language)
	var max_version int32
	err := row.Scan(&max_version)
	return max_version, err
}

const getMonthlySpecViewUsage = `-- name: GetMonthlySpecViewUsage :one
SELECT COALESCE(SUM(quota_amount), 0)::int as total
FROM usage_events
WHERE user_id = $1
  AND event_type = 'specview'
  AND created_at >= date_trunc('month', CURRENT_DATE)
`

func (q *Queries) GetMonthlySpecViewUsage(ctx context.Context, userID pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getMonthlySpecViewUsage, userID)
	var total int32
	err := row.Scan(&total)
	return total, err
}

const getOAuthAccountByUserAndProvider = `-- name: GetOAuthAccountByUserAndProvider :one
SELECT id, user_id, provider, provider_user_id, provider_username, access_token, scope, created_at, updated_at FROM oauth_accounts WHERE user_id = $1 AND provider = $2
`

type GetOAuthAccountByUserAndProviderParams struct {
	UserID   pgtype.UUID   `json:"user_id"`
	Provider OauthProvider `json:"provider"`
}

func (q *Queries) GetOAuthAccountByUserAndProvider(ctx context.Context, arg GetOAuthAccountByUserAndProviderParams) (OauthAccount, error) {
	row := q.db.QueryRow(ctx, getOAuthAccountByUserAndProvider, arg.UserID, arg.Provider)
	var i OauthAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.ProviderUserID,
		&i.ProviderUsername,
		&i.AccessToken,
		&i.Scope,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSystemConfig = `-- name: GetSystemConfig :one
SELECT value FROM system_config WHERE key = $1
`

func (q *Queries) GetSystemConfig(ctx context.Context, key string) (string, error) {
	row := q.db.QueryRow(ctx, getSystemConfig, key)
	var value string
	err := row.Scan(&value)
	return value, err
}

const getTestCasesBySuiteID = `-- name: GetTestCasesBySuiteID :many
SELECT id, suite_id, name, line_number, status, tags, modifier FROM test_cases WHERE suite_id = $1 ORDER BY line_number
`

func (q *Queries) GetTestCasesBySuiteID(ctx context.Context, suiteID pgtype.UUID) ([]TestCase, error) {
	rows, err := q.db.Query(ctx, getTestCasesBySuiteID, suiteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TestCase{}
	for rows.Next() {
		var i TestCase
		if err := rows.Scan(
			&i.ID,
			&i.SuiteID,
			&i.Name,
			&i.LineNumber,
			&i.Status,
			&i.Tags,
			&i.Modifier,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestDataByAnalysisID = `-- name: GetTestDataByAnalysisID :many
SELECT
    tf.id as file_id,
    tf.file_path,
    tf.framework,
    tf.domain_hints,
    ts.id as suite_id,
    ts.parent_id as suite_parent_id,
    ts.name as suite_name,
    ts.depth as suite_depth,
    tc.id as test_case_id,
    tc.name as test_name
FROM test_files tf
JOIN test_suites ts ON ts.file_id = tf.id
JOIN test_cases tc ON tc.suite_id = ts.id
WHERE tf.analysis_id = $1
ORDER BY tf.file_path, ts.depth, ts.name, tc.name
`

type GetTestDataByAnalysisIDRow struct {
	FileID        pgtype.UUID `json:"file_id"`
	FilePath      string      `json:"file_path"`
	Framework     pgtype.Text `json:"framework"`
	DomainHints   []byte      `json:"domain_hints"`
	SuiteID       pgtype.UUID `json:"suite_id"`
	SuiteParentID pgtype.UUID `json:"suite_parent_id"`
	SuiteName     string      `json:"suite_name"`
	SuiteDepth    int32       `json:"suite_depth"`
	TestCaseID    pgtype.UUID `json:"test_case_id"`
	TestName      string      `json:"test_name"`
}

func (q *Queries) GetTestDataByAnalysisID(ctx context.Context, analysisID pgtype.UUID) ([]GetTestDataByAnalysisIDRow, error) {
	rows, err := q.db.Query(ctx, getTestDataByAnalysisID, analysisID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTestDataByAnalysisIDRow{}
	for rows.Next() {
		var i GetTestDataByAnalysisIDRow
		if err := rows.Scan(
			&i.FileID,
			&i.FilePath,
			&i.Framework,
			&i.DomainHints,
			&i.SuiteID,
			&i.SuiteParentID,
			&i.SuiteName,
			&i.SuiteDepth,
			&i.TestCaseID,
			&i.TestName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestSuitesByFileID = `-- name: GetTestSuitesByFileID :many
SELECT id, parent_id, name, line_number, depth, file_id FROM test_suites WHERE file_id = $1 ORDER BY line_number
`

func (q *Queries) GetTestSuitesByFileID(ctx context.Context, fileID pgtype.UUID) ([]TestSuite, error) {
	rows, err := q.db.Query(ctx, getTestSuitesByFileID, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TestSuite{}
	for rows.Next() {
		var i TestSuite
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.Name,
			&i.LineNumber,
			&i.Depth,
			&i.FileID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertSpecDocument = `-- name: InsertSpecDocument :one
INSERT INTO spec_documents (user_id, analysis_id, content_hash, language, model_id, version)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

type InsertSpecDocumentParams struct {
	UserID      pgtype.UUID `json:"user_id"`
	AnalysisID  pgtype.UUID `json:"analysis_id"`
	ContentHash []byte      `json:"content_hash"`
	Language    string      `json:"language"`
	ModelID     string      `json:"model_id"`
	Version     int32       `json:"version"`
}

func (q *Queries) InsertSpecDocument(ctx context.Context, arg InsertSpecDocumentParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertSpecDocument,
		arg.UserID,
		arg.AnalysisID,
		arg.ContentHash,
		arg.Language,
		arg.ModelID,
		arg.Version,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const insertSpecDomain = `-- name: InsertSpecDomain :one
INSERT INTO spec_domains (document_id, name, description, sort_order, classification_confidence)
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type InsertSpecDomainParams struct {
	DocumentID               pgtype.UUID    `json:"document_id"`
	Name                     string         `json:"name"`
	Description              pgtype.Text    `json:"description"`
	SortOrder                int32          `json:"sort_order"`
	ClassificationConfidence pgtype.Numeric `json:"classification_confidence"`
}

func (q *Queries) InsertSpecDomain(ctx context.Context, arg InsertSpecDomainParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertSpecDomain,
		arg.DocumentID,
		arg.Name,
		arg.Description,
		arg.SortOrder,
		arg.ClassificationConfidence,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const insertSpecFeature = `-- name: InsertSpecFeature :one
INSERT INTO spec_features (domain_id, name, description, sort_order)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type InsertSpecFeatureParams struct {
	DomainID    pgtype.UUID `json:"domain_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	SortOrder   int32       `json:"sort_order"`
}

func (q *Queries) InsertSpecFeature(ctx context.Context, arg InsertSpecFeatureParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertSpecFeature,
		arg.DomainID,
		arg.Name,
		arg.Description,
		arg.SortOrder,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const insertTestFile = `-- name: InsertTestFile :one
INSERT INTO test_files (analysis_id, file_path, framework, domain_hints)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type InsertTestFileParams struct {
	AnalysisID  pgtype.UUID `json:"analysis_id"`
	FilePath    string      `json:"file_path"`
	Framework   pgtype.Text `json:"framework"`
	DomainHints []byte      `json:"domain_hints"`
}

func (q *Queries) InsertTestFile(ctx context.Context, arg InsertTestFileParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertTestFile,
		arg.AnalysisID,
		arg.FilePath,
		arg.Framework,
		arg.DomainHints,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const insertTestSuite = `-- name: InsertTestSuite :one
INSERT INTO test_suites (file_id, parent_id, name, line_number, depth)
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type InsertTestSuiteParams struct {
	FileID     pgtype.UUID `json:"file_id"`
	ParentID   pgtype.UUID `json:"parent_id"`
	Name       string      `json:"name"`
	LineNumber pgtype.Int4 `json:"line_number"`
	Depth      int32       `json:"depth"`
}

func (q *Queries) InsertTestSuite(ctx context.Context, arg InsertTestSuiteParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertTestSuite,
		arg.FileID,
		arg.ParentID,
		arg.Name,
		arg.LineNumber,
		arg.Depth,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const markCodebaseStale = `-- name: MarkCodebaseStale :exec
UPDATE codebases SET is_stale = true, updated_at = now() WHERE id = $1
`

func (q *Queries) MarkCodebaseStale(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markCodebaseStale, id)
	return err
}

const recordAnalysisUsageEvent = `-- name: RecordAnalysisUsageEvent :exec
INSERT INTO usage_events (user_id, event_type, analysis_id, quota_amount)
VALUES ($1, 'analysis', $2, $3)
`

type RecordAnalysisUsageEventParams struct {
	UserID      pgtype.UUID `json:"user_id"`
	AnalysisID  pgtype.UUID `json:"analysis_id"`
	QuotaAmount int32       `json:"quota_amount"`
}

func (q *Queries) RecordAnalysisUsageEvent(ctx context.Context, arg RecordAnalysisUsageEventParams) error {
	_, err := q.db.Exec(ctx, recordAnalysisUsageEvent, arg.UserID, arg.AnalysisID, arg.QuotaAmount)
	return err
}

const recordSpecViewUsageEvent = `-- name: RecordSpecViewUsageEvent :exec

INSERT INTO usage_events (user_id, event_type, document_id, quota_amount)
VALUES ($1, 'specview', $2, $3)
`

type RecordSpecViewUsageEventParams struct {
	UserID      pgtype.UUID `json:"user_id"`
	DocumentID  pgtype.UUID `json:"document_id"`
	QuotaAmount int32       `json:"quota_amount"`
}

// =============================================================================
// USAGE EVENTS
// =============================================================================
func (q *Queries) RecordSpecViewUsageEvent(ctx context.Context, arg RecordSpecViewUsageEventParams) error {
	_, err := q.db.Exec(ctx, recordSpecViewUsageEvent, arg.UserID, arg.DocumentID, arg.QuotaAmount)
	return err
}

const recordUserAnalysisHistory = `-- name: RecordUserAnalysisHistory :exec
INSERT INTO user_analysis_history (user_id, analysis_id)
VALUES ($1, $2)
ON CONFLICT ON CONSTRAINT uq_user_analysis_history_user_analysis
DO UPDATE SET updated_at = now()
`

type RecordUserAnalysisHistoryParams struct {
	UserID     pgtype.UUID `json:"user_id"`
	AnalysisID pgtype.UUID `json:"analysis_id"`
}

func (q *Queries) RecordUserAnalysisHistory(ctx context.Context, arg RecordUserAnalysisHistoryParams) error {
	_, err := q.db.Exec(ctx, recordUserAnalysisHistory, arg.UserID, arg.AnalysisID)
	return err
}

const recordUserSpecviewHistory = `-- name: RecordUserSpecviewHistory :exec
INSERT INTO user_specview_history (user_id, document_id)
VALUES ($1, $2)
ON CONFLICT ON CONSTRAINT uq_user_specview_history_user_document
DO UPDATE SET updated_at = now()
`

type RecordUserSpecviewHistoryParams struct {
	UserID     pgtype.UUID `json:"user_id"`
	DocumentID pgtype.UUID `json:"document_id"`
}

func (q *Queries) RecordUserSpecviewHistory(ctx context.Context, arg RecordUserSpecviewHistoryParams) error {
	_, err := q.db.Exec(ctx, recordUserSpecviewHistory, arg.UserID, arg.DocumentID)
	return err
}

const unmarkCodebaseStale = `-- name: UnmarkCodebaseStale :one
UPDATE codebases
SET is_stale = false, owner = $2, name = $3, updated_at = now()
WHERE id = $1
RETURNING id, host, owner, name, default_branch, created_at, updated_at, last_viewed_at, external_repo_id, is_stale, is_private
`

type UnmarkCodebaseStaleParams struct {
	ID    pgtype.UUID `json:"id"`
	Owner string      `json:"owner"`
	Name  string      `json:"name"`
}

func (q *Queries) UnmarkCodebaseStale(ctx context.Context, arg UnmarkCodebaseStaleParams) (Codebasis, error) {
	row := q.db.QueryRow(ctx, unmarkCodebaseStale, arg.ID, arg.Owner, arg.Name)
	var i Codebasis
	err := row.Scan(
		&i.ID,
		&i.Host,
		&i.Owner,
		&i.Name,
		&i.DefaultBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastViewedAt,
		&i.ExternalRepoID,
		&i.IsStale,
		&i.IsPrivate,
	)
	return i, err
}

const updateAnalysisCompleted = `-- name: UpdateAnalysisCompleted :exec
UPDATE analyses
SET status = 'completed', total_suites = $2, total_tests = $3, completed_at = $4, committed_at = $5
WHERE id = $1
`

type UpdateAnalysisCompletedParams struct {
	ID          pgtype.UUID        `json:"id"`
	TotalSuites int32              `json:"total_suites"`
	TotalTests  int32              `json:"total_tests"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
	CommittedAt pgtype.Timestamptz `json:"committed_at"`
}

func (q *Queries) UpdateAnalysisCompleted(ctx context.Context, arg UpdateAnalysisCompletedParams) error {
	_, err := q.db.Exec(ctx, updateAnalysisCompleted,
		arg.ID,
		arg.TotalSuites,
		arg.TotalTests,
		arg.CompletedAt,
		arg.CommittedAt,
	)
	return err
}

const updateAnalysisFailed = `-- name: UpdateAnalysisFailed :exec
UPDATE analyses
SET status = 'failed', error_message = $2, completed_at = $3
WHERE id = $1
`

type UpdateAnalysisFailedParams struct {
	ID           pgtype.UUID        `json:"id"`
	ErrorMessage pgtype.Text        `json:"error_message"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) UpdateAnalysisFailed(ctx context.Context, arg UpdateAnalysisFailedParams) error {
	_, err := q.db.Exec(ctx, updateAnalysisFailed, arg.ID, arg.ErrorMessage, arg.CompletedAt)
	return err
}

const updateCodebaseOwnerName = `-- name: UpdateCodebaseOwnerName :one
UPDATE codebases
SET owner = $2, name = $3, updated_at = now()
WHERE id = $1
RETURNING id, host, owner, name, default_branch, created_at, updated_at, last_viewed_at, external_repo_id, is_stale, is_private
`

type UpdateCodebaseOwnerNameParams struct {
	ID    pgtype.UUID `json:"id"`
	Owner string      `json:"owner"`
	Name  string      `json:"name"`
}

func (q *Queries) UpdateCodebaseOwnerName(ctx context.Context, arg UpdateCodebaseOwnerNameParams) (Codebasis, error) {
	row := q.db.QueryRow(ctx, updateCodebaseOwnerName, arg.ID, arg.Owner, arg.Name)
	var i Codebasis
	err := row.Scan(
		&i.ID,
		&i.Host,
		&i.Owner,
		&i.Name,
		&i.DefaultBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastViewedAt,
		&i.ExternalRepoID,
		&i.IsStale,
		&i.IsPrivate,
	)
	return i, err
}

const updateCodebaseVisibility = `-- name: UpdateCodebaseVisibility :exec
UPDATE codebases
SET is_private = $2, updated_at = now()
WHERE id = $1
`

type UpdateCodebaseVisibilityParams struct {
	ID        pgtype.UUID `json:"id"`
	IsPrivate bool        `json:"is_private"`
}

func (q *Queries) UpdateCodebaseVisibility(ctx context.Context, arg UpdateCodebaseVisibilityParams) error {
	_, err := q.db.Exec(ctx, updateCodebaseVisibility, arg.ID, arg.IsPrivate)
	return err
}

const upsertBehaviorCache = `-- name: UpsertBehaviorCache :exec
INSERT INTO behavior_caches (cache_key_hash, converted_description)
VALUES ($1, $2)
ON CONFLICT (cache_key_hash) DO UPDATE
SET converted_description = EXCLUDED.converted_description
`

type UpsertBehaviorCacheParams struct {
	CacheKeyHash         []byte `json:"cache_key_hash"`
	ConvertedDescription string `json:"converted_description"`
}

func (q *Queries) UpsertBehaviorCache(ctx context.Context, arg UpsertBehaviorCacheParams) error {
	_, err := q.db.Exec(ctx, upsertBehaviorCache, arg.CacheKeyHash, arg.ConvertedDescription)
	return err
}

const upsertClassificationCache = `-- name: UpsertClassificationCache :exec
INSERT INTO classification_caches (content_hash, language, model_id, phase1_output, test_index_map)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT ON CONSTRAINT uq_classification_caches_key DO UPDATE
SET phase1_output = EXCLUDED.phase1_output,
    test_index_map = EXCLUDED.test_index_map,
    created_at = now()
`

type UpsertClassificationCacheParams struct {
	ContentHash  []byte `json:"content_hash"`
	Language     string `json:"language"`
	ModelID      string `json:"model_id"`
	Phase1Output []byte `json:"phase1_output"`
	TestIndexMap []byte `json:"test_index_map"`
}

func (q *Queries) UpsertClassificationCache(ctx context.Context, arg UpsertClassificationCacheParams) error {
	_, err := q.db.Exec(ctx, upsertClassificationCache,
		arg.ContentHash,
		arg.Language,
		arg.ModelID,
		arg.Phase1Output,
		arg.TestIndexMap,
	)
	return err
}

const upsertCodebase = `-- name: UpsertCodebase :one
INSERT INTO codebases (host, owner, name, default_branch, external_repo_id, is_private)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (host, external_repo_id)
DO UPDATE SET
    owner = EXCLUDED.owner,
    name = EXCLUDED.name,
    default_branch = COALESCE(EXCLUDED.default_branch, codebases.default_branch),
    is_stale = false,
    is_private = EXCLUDED.is_private,
    updated_at = now()
RETURNING id, host, owner, name, default_branch, created_at, updated_at, last_viewed_at, external_repo_id, is_stale, is_private
`

type UpsertCodebaseParams struct {
	Host           string      `json:"host"`
	Owner          string      `json:"owner"`
	Name           string      `json:"name"`
	DefaultBranch  pgtype.Text `json:"default_branch"`
	ExternalRepoID string      `json:"external_repo_id"`
	IsPrivate      bool        `json:"is_private"`
}

func (q *Queries) UpsertCodebase(ctx context.Context, arg UpsertCodebaseParams) (Codebasis, error) {
	row := q.db.QueryRow(ctx, upsertCodebase,
		arg.Host,
		arg.Owner,
		arg.Name,
		arg.DefaultBranch,
		arg.ExternalRepoID,
		arg.IsPrivate,
	)
	var i Codebasis
	err := row.Scan(
		&i.ID,
		&i.Host,
		&i.Owner,
		&i.Name,
		&i.DefaultBranch,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastViewedAt,
		&i.ExternalRepoID,
		&i.IsStale,
		&i.IsPrivate,
	)
	return i, err
}

const upsertSystemConfig = `-- name: UpsertSystemConfig :exec
INSERT INTO system_config (key, value, updated_at)
VALUES ($1, $2, now())
ON CONFLICT (key)
DO UPDATE SET value = EXCLUDED.value, updated_at = now()
`

type UpsertSystemConfigParams struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (q *Queries) UpsertSystemConfig(ctx context.Context, arg UpsertSystemConfigParams) error {
	_, err := q.db.Exec(ctx, upsertSystemConfig, arg.Key, arg.Value)
	return err
}
